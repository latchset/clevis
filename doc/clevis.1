'\" t
.\"     Title: clevis
.\"    Author: [FIXME: author] [see http://www.docbook.org/tdg5/en/html/author]
.\" Generator: DocBook XSL Stylesheets vsnapshot <http://docbook.sf.net/>
.\"      Date: 07/12/2018
.\"    Manual: \ \&
.\"    Source: \ \&
.\"  Language: English
.\"
.TH "CLEVIS" "1" "07/12/2018" "\ \&" "\ \&"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
clevis \- Automated decryption policy framework
.SH "SYNOPSIS"
.sp
\fBclevis\fR COMMAND [OPTIONS]
.SH "OVERVIEW"
.sp
Clevis is a framework for automated decryption policy\&. It allows you to define a policy at encryption time that must be satisfied for the data to decrypt\&. Once this policy is met, the data is decrypted\&.
.sp
Clevis is pluggable\&. Our plugins are called pins\&. The job of a pin is to take a policy as its first argument and plaintext on standard input and to encrypt the data so that it can be automatically decrypted if the policy is met\&. Lets walk through an example\&.
.SH "HTTP ESCROW"
.sp
When using the HTTP pin, we create a new, cryptographically\-strong, random key\&. This key is stored in a remote HTTP escrow server (using a simple PUT or POST)\&. Then at decryption time, we attempt to fetch the key back again in order to decrypt our data\&. So, for our configuration we need to pass the URL to the key location:
.sp
.if n \{\
.RS 4
.\}
.nf
$ clevis encrypt http \*(Aq{"url":"https://escrow\&.srv/1234"}\*(Aq < PT > JWE
.fi
.if n \{\
.RE
.\}
.sp
To decrypt the data, simply provide the ciphertext (JWE):
.sp
.if n \{\
.RS 4
.\}
.nf
$ clevis decrypt < JWE > PLAINTEXT
.fi
.if n \{\
.RE
.\}
.sp
Notice that we did not pass any configuration during decryption\&. The decrypt command extracted the URL (and possibly other configuration) from the JWE object, fetched the encryption key from the escrow and performed decryption\&.
.sp
For more information, see \fBclevis\-encrypt\-http\fR(1)\&.
.SH "TANG BINDING"
.sp
Clevis provides support for the Tang network binding server\&. Tang provides a stateless, lightweight alternative to escrows\&. Encrypting data using the Tang pin works much like our HTTP pin above:
.sp
.if n \{\
.RS 4
.\}
.nf
$ clevis encrypt tang \*(Aq{"url":"http://tang\&.srv"}\*(Aq < PT > JWE
The advertisement contains the following signing keys:
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
_OsIk0T\-E2l6qjfdDiwVmidoZjA
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
Do you wish to trust these keys? [ynYN] y
.fi
.if n \{\
.RE
.\}
.sp
As you can see above, Tang utilizes a trust\-on\-first\-use workflow\&. Alternatively, Tang can perform entirely offline encryption if you pre\-share the server advertisement\&. Decryption, too works like our first example:
.sp
.if n \{\
.RS 4
.\}
.nf
$ clevis decrypt < JWE > PT
.fi
.if n \{\
.RE
.\}
.sp
For more information, see \fBclevis\-encrypt\-tang\fR(1)\&.
.SH "TPM2 BINDING"
.sp
Clevis provides support to encrypt a key in a Trusted Platform Module 2\&.0 (TPM2) chip\&. The cryptographically\-strong, random key used for encryption is encrypted using the TPM2 chip, and then at decryption time is decrypted using the TPM2 to allow clevis to decrypt the secret stored in the JWE\&.
.sp
Encrypting data using the tpm2 pin works the same than the pins mentioned above:
.sp
.if n \{\
.RS 4
.\}
.nf
$ clevis encrypt tpm2 \*(Aq{}\*(Aq < PT > JWE
.fi
.if n \{\
.RE
.\}
.sp
The pin has reasonable defaults for its configuration, but a different hierarchy, hash, and key algorithms can be chosen if the defaults used are not suitable\&.
.sp
Decryption also works similar to other pins, only the JWE needs to be provided:
.sp
.if n \{\
.RS 4
.\}
.nf
$ clevis decrypt < JWE > PT
.fi
.if n \{\
.RE
.\}
.sp
Note that like other pins no configuration is used for decryption, this is due clevis storing the public and private keys to unseal the TPM2 encrypted object in the JWE so clevis can fetch that information from there\&.
.sp
For more information see \fBclevis\-encrypt\-tpm2\fR(1)\&.
.SH "SHAMIR\(cqS SECRET SHARING"
.sp
Clevis provides a way to mix pins together to create sophisticated unlocking and high availability policies\&. This is accomplished by using an algorithm called Shamir\(cqs Secret Sharing (SSS)\&.
.sp
SSS is a thresholding scheme\&. It creates a key and divides it into a number of pieces\&. Each piece is encrypted using another pin (possibly even SSS recursively)\&. Additionally, you define the threshold \fBt\fR\&. If at least \fBt\fR pieces can be decrypted, then the encryption key can be recovered and decryption can succeed\&.
.sp
For example, let\(cqs create a high\-availability setup using Tang:
.sp
.if n \{\
.RS 4
.\}
.nf
$ cfg=\*(Aq{"t":1,"pins":{"tang":[{"url":\&.\&.\&.},{"url":\&.\&.\&.}]}}\*(Aq
$ clevis encrypt sss "$cfg" < PT > JWE
.fi
.if n \{\
.RE
.\}
.sp
In this policy, we are declaring that we have a threshold of 1, but that there are multiple key fragments encrypted using different Tang servers\&. Since our threshold is 1, so long as any of the Tang servers are available, decryption will succeed\&. As always, decryption is simply:
.sp
.if n \{\
.RS 4
.\}
.nf
$ clevis decrypt < JWE > PT
.fi
.if n \{\
.RE
.\}
.sp
For more information, see \fBclevis\-encrypt\-tang\fR(1)\&.
.SH "LUKS BINDING"
.sp
Clevis can be used to bind an existing LUKS volume to its automation policy\&. This is accomplished with a simple command:
.sp
.if n \{\
.RS 4
.\}
.nf
$ clevis luks bind \-d /dev/sda tang \*(Aq{"url":\&.\&.\&.}\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
This command performs four steps:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
Creates a new key with the same entropy as the LUKS master key\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
Encrypts the new key with Clevis\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
Stores the Clevis JWE in the LUKS header with LUKSMeta\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
Enables the new key for use with LUKS\&.
.RE
.sp
This disk can now be unlocked with your existing password as well as with the Clevis policy\&. Clevis provides two unlockers for LUKS volumes\&. First, we provide integration with Dracut to automatically unlock your root volume during early boot\&. Second, we provide integration with UDisks2 to automatically unlock your removable media in your desktop session\&.
.sp
For more information, see \fBclevis\-luks\-bind\fR(1)\&.
.SH "SEE ALSO"
.sp
\fBclevis\-encrypt\-http\fR(1), \fBclevis\-encrypt\-tang\fR(1), \fBclevis\-encrypt\-tpm2\fR(1), \fBclevis\-encrypt\-sss\fR(1), \fBclevis\-luks\-bind\fR(1), \fBclevis\-decrypt\fR(1)
